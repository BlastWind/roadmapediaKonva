//todo: allow for picture inside of rect/circle/star
//todo: work on path (connect using arrow)
//todo: delete elements
//todo: able to resize canva on zoom
//todo: for rightToolBar, show fontSize,fontFamily for text for the rest allow to add pictures

import React, { Component } from "react";
import Konva from "konva";
import { render } from "react-dom";
import ReactDOM from "react-dom";
import {
  Stage,
  Layer,
  Rect,
  Transformer,
  Circle,
  Star,
  Text,
  Arrow
} from "react-konva";
import Toolbar from "./Toolbar.js";

class TransformerComponent extends React.Component {
  componentDidMount() {
    this.checkNode();
  }
  componentDidUpdate() {
    this.checkNode();
  }
  checkNode() {
    const stage = this.transformer.getStage();

    ///// to bhe removed

    /////
    //console.log(stage);
    //console.log(this.props);

    const { selectedShapeName } = this.props;
    const selectedNode = stage.findOne("." + selectedShapeName);
    if (selectedNode === this.transformer.node()) {
      return;
    }
    if (selectedNode) {
      this.transformer.attachTo(selectedNode);
    } else {
      this.transformer.detach();
    }
    this.transformer.getLayer().batchDraw();
  }
  render() {
    return (
      <Transformer
        ref={node => {
          this.transformer = node;
        }}
        name="transformer"
      />
    );
  }
}

class Graphics extends Component {
  state = {
    selectedShapeName: "",

    rectangles: [],
    circles: [],
    stars: [],
    texts: [],
    arrows: [],

    textX: 0,
    textY: 0,
    textEditVisible: false,
    arrowDraggable: false,
    newArrowRef: ""
    //arrowEndX:0,
    //arrowEndY:0
  };
  handleStageClick = e => {
    this.setState({
      selectedShapeName: e.target.name()
    });
    console.log(e.target);
    this.props.onSelect(e.target.name());

    //arrow logic, there's e.evt.pageX, pageY
    this.setState({ arrowDraggable: false });

    console.log(this.state);
    if (this.state.newArrowRef != "") {
      let arrowRef = this.state.newArrowRef;
      let arrow = this.refs.graphicStage.findOne("." + this.state.newArrowRef);

      arrow.setAttr("points", [
        this.refs.graphicStage.findOne("." + this.state.newArrowRef).attrs
          .points[0],
        this.refs.graphicStage.findOne("." + this.state.newArrowRef).attrs
          .points[1],
        this.state.arrowEndX,
        this.state.arrowEndY
      ]);
      console.log(arrow);
      arrow.draw();
      this.setState({ newArrowRef: "" });
    }

    /*let arrow = this.refs.graphicStage.findOne("." + eachRef);
    arrow.setAttr("points", [
      this.refs.graphicStage.findOne("." + eachRef).attrs
        .points[0],
      this.refs.graphicStage.findOne("." + eachRef).attrs
        .points[1],
      this.state.arrowEndX,
      this.state.arrowEndY
    ]);

    arrow.draw();
    this.refs.layer.draw();*/
  };

  handleMouseOver = e => {
    if (this.state.arrowDraggable) {
      this.setState({
        arrowEndX: e.evt.pageX,
        arrowEndY:
          e.evt.pageY -
          document.getElementById("NavBar").getBoundingClientRect().height
      });
    }
  };

  componentDidMount() {
    var stage = this.refs.graphicStage;
    this.props.stage(stage);
    console.log(stage);
  }
  render() {
    return (
      <React.Fragment>
        <Stage
          onClick={this.handleStageClick}
          onMouseMove={this.handleMouseOver}
          height={window.innerHeight}
          width={window.innerWidth}
          ref="graphicStage"
        >
          <Layer height={window.innerHeight} width={window.innerWidth}>
            {this.state.rectangles.map(eachRect => (
              <Rect
                name={eachRect.name}
                x={eachRect.x}
                y={eachRect.y}
                width={eachRect.width}
                height={eachRect.height}
                fill={eachRect.fill}
                stroke={eachRect.stroke}
                strokeWidth={eachRect.strokeWidth}
                draggable
              />
            ))}
            {this.state.circles.map(eachCircle => (
              <Circle
                name={eachCircle.name}
                x={eachCircle.x}
                y={eachCircle.y}
                radius={eachCircle.radius}
                fill={eachCircle.fill}
                stroke={eachCircle.stroke}
                strokeWidth={eachCircle.strokeWidth}
                draggable
              />
            ))}
            {this.state.stars.map(eachStar => (
              <Star
                name={eachStar.name}
                x={eachStar.x}
                y={eachStar.y}
                innerRadius={eachStar.innerRadius}
                outerRadius={eachStar.outerRadius}
                numPoints={eachStar.numPoints}
                stroke={eachStar.stroke}
                strokeWidth={eachStar.strokeWidth}
                draggable
              />
            ))}
            {this.state.texts.map(eachText => (
              //perhaps this.state.texts only need to contain refs?
              //so that we only need to store the refs to get more information
              <Text
                name={eachText.name}
                ref={eachText.ref}
                fontFamily={eachText.fontFamily}
                fontSize={eachText.fontSize}
                x={eachText.x}
                y={eachText.y}
                text={eachText.text}
                draggable
                onDblClick={() => {
                  // turn into textarea
                  var stage = this.refs.graphicStage;
                  var text = stage.findOne("." + eachText.name);
                  console.log(text);
                  this.setState({
                    textX: text.absolutePosition().x,
                    textY: text.absolutePosition().y,
                    textEditVisible: !this.state.textEditVisible,
                    text: eachText.text,
                    currentTextRef: eachText.ref,
                    textareaWidth: text.textWidth,
                    textareaHeight: text.textHeight,
                    textareaFill: text.attrs.fill,
                    textareaFontFamily: text.attrs.fontFamily,
                    textareaFontSize: text.attrs.fontSize
                  });
                  let textarea = this.refs.textarea;
                  textarea.focus();
                  text.hide();
                  var transformer = stage.findOne(".transformer");
                  transformer.hide();
                  stage.draw();
                }}
              />
            ))}
            {this.state.arrows.map(eachRef => {
              if (eachRef == this.state.newArrowRef) {
                return (
                  <Arrow
                    ref={eachRef}
                    name={eachRef}
                    points={[
                      this.refs.graphicStage.findOne("." + eachRef).attrs
                        .points[0],
                      this.refs.graphicStage.findOne("." + eachRef).attrs
                        .points[1],
                      this.state.arrowDraggable
                        ? this.state.arrowEndX
                        : this.refs.graphicStage.findOne("." + eachRef).attrs
                            .points[2],
                      this.state.arrowDraggable
                        ? this.state.arrowEndY
                        : this.refs.graphicStage.findOne("." + eachRef).attrs
                            .points[3]
                    ]}
                    fill="black"
                    stroke="black"
                    //x={this.refs.graphicStage.findOne("." + eachRef).attrs.x}
                    //y={this.refs.graphicStage.findOne("." + eachRef).attrs.y}
                    draggable
                  />
                );
              } else {
                return (
                  <Arrow
                    ref={eachRef}
                    name={eachRef}
                    points={[
                      this.refs.graphicStage.findOne("." + eachRef).attrs
                        .points[0],
                      this.refs.graphicStage.findOne("." + eachRef).attrs
                        .points[1],
                      this.refs.graphicStage.findOne("." + eachRef).attrs
                        .points[2],
                      this.refs.graphicStage.findOne("." + eachRef).attrs
                        .points[3]
                    ]}
                    fill="black"
                    stroke="black"
                    draggable
                  />
                );
              }
            })}
            <TransformerComponent
              selectedShapeName={this.state.selectedShapeName}
            />
          </Layer>

          <Layer
            height={window.innerHeight}
            width={window.innerWidth}
            ref="layer"
            draggable
          >
            <Toolbar
              rectName={this.state.rectangles.length + 1}
              circleName={this.state.circles.length + 1}
              starName={this.state.stars.length + 1}
              textName={this.state.texts.length + 1}
              newArrowOnDragEnd={position => {
                var newArrow = new Konva.Arrow({
                  points: [position.x, position.y, position.x, position.y],

                  ref: "arrow" + (this.state.arrows.length + 1),
                  name: "arrow" + (this.state.arrows.length + 1)
                });

                this.state.arrows.push(newArrow);
                this.setState({ newArrowRef: newArrow.attrs.name });
                this.forceUpdate();
                //this.refs updates after forceUpdate (because arrow gets instantiated), might be risky in the future
                console.log(this.refs);
                //only this.state.arrows.length because it was pushed earlier, cancelling the +1
                let ref = "arrow" + this.state.arrows.length;
                let arrow = this.refs[ref];

                this.setState({
                  arrowDraggable: !this.state.arrowDraggable,
                  newArrowRef: newArrow.attrs.name
                });
                this.forceUpdate();
                console.log(this.state.arrowDraggable);
              }}
              appendToRectangles={stuff => {
                var layer = this.refs.layer;
                var toPush = stuff;
                if (layer.attrs.x != null || layer.attrs.x != undefined) {
                  toPush.x = stuff.x + layer.attrs.x;
                  toPush.y = stuff.y + layer.attrs.y;
                }
                this.state.rectangles.push(toPush);
                this.forceUpdate();
              }}
              appendToCircles={stuff => {
                var layer = this.refs.layer;
                var toPush = stuff;
                if (layer.attrs.x != null || layer.attrs.x != undefined) {
                  toPush.x = stuff.x + layer.attrs.x;
                  toPush.y = stuff.y + layer.attrs.y;
                }
                this.state.circles.push(toPush);
                this.forceUpdate();
              }}
              appendToStars={stuff => {
                var layer = this.refs.layer;
                var toPush = stuff;
                if (layer.attrs.x != null || layer.attrs.x != undefined) {
                  toPush.x = stuff.x + layer.attrs.x;
                  toPush.y = stuff.y + layer.attrs.y;
                }
                this.state.stars.push(toPush);
                this.forceUpdate();
              }}
              appendToTexts={stuff => {
                var layer = this.refs.layer;
                var toPush = stuff;
                if (layer.attrs.x != null || layer.attrs.x != undefined) {
                  toPush.x = stuff.x + layer.attrs.x;
                  toPush.y = stuff.y + layer.attrs.y;
                }
                this.state.texts.push(toPush);
                this.forceUpdate();
                //we can also just get element by this.refs.toPush.ref
                let stage = this.refs.graphicStage;
                //  let text = stage.findOne("." + toPush.name);
                let text = this.refs[toPush.ref];

                text.fire("dblclick");
              }}
            />
          </Layer>
        </Stage>
        <textarea
          ref="textarea"
          value={this.state.text}
          onChange={e => {
            this.setState({ text: e.target.value });
          }}
          onKeyDown={e => {
            if (e.keyCode === 13) {
              this.setState({ textEditVisible: false });

              // get the current textNode we are editing, get the name from there
              //match name with elements in this.state.texts,
              let node = this.refs[this.state.currentTextRef];

              let name = node.attrs.name;
              let matched = this.state.texts.filter(eachText => {
                if (eachText.name == name) {
                  return eachText;
                }
              });

              matched[0].text = this.state.text;
              node.show();
              this.refs.graphicStage.findOne(".transformer").show();
            }
          }}
          onBlur={() => {
            this.setState({ textEditVisible: false });

            // get the current textNode we are editing, get the name from there
            //match name with elements in this.state.texts,
            let node = this.refs[this.state.currentTextRef];

            let name = node.attrs.name;
            let matched = this.state.texts.filter(eachText => {
              if (eachText.name == name) {
                return eachText;
              }
            });

            matched[0].text = this.state.text;
            node.show();
            this.refs.graphicStage.findOne(".transformer").show();
            this.refs.graphicStage.draw();
          }}
          style={{
            //set position, width, height, fontSize, overflow, lineHeight, color
            display: this.state.textEditVisible ? "block" : "none",
            position: "absolute",
            top: this.state.textY + 80 + "px",
            left: this.state.textX + "px",
            width: "auto",
            height: "auto",
            overflow: "hidden",
            fontSize: this.state.textareaFontSize,
            fontFamily: this.state.textareaFontFamily,
            color: this.state.textareaFill,
            border: "none",
            padding: "0px",
            margin: "0px",
            outline: "none",
            resize: "none",
            background: "none"
          }}
        />
      </React.Fragment>
    );
  }
}

export default Graphics;
